blueprint:
  name: Google Cast resume
  description: A script that will resume Google Cast enabled devices after the audio
    stream  has been intrerrupted, e.g. by receiving a TTS or playing another mp3
  domain: script
  source_url: https://github.com/TheFes/HA-configuration/blob/main/blueprints/script/google_home_resume.yaml
  input:
    target_entities:
      description: Enter the targets in case they are not clear from the service calls
      selector:
        target:
          entity:
            integration: cast
            domain: media_player
          device:
            integration: cast
    actions_to_perform:
      description: Actions to be performed (only service calls will work)
      selector:
        action: {}
    primary_spotcast:
      name: Primary Spotcast account
      description: Used to match the spotify media player with the primary spotcast
        account
      selector:
        text: {}
    default_volume_level:
      name: Default volume level
      description: Used in case the volume level could not be retreived
      default: 0.25
      selector:
        number:
          min: 0.0
          max: 1.0
          step: 0.05
          mode: slider
mode: restart
sequence:
- alias: Convert variables from blueprint input
  variables:
    speaker_groups:
      media_player.huis_groep:
      - media_player.keuken_hub
      - media_player.slaapkamer_hub
      - media_player.pepijn_mini
      - media_player.woonkamer_mini
      - media_player.zolder_mini_marleen
      - media_player.zolder_mini_martijn
      - media_player.floris_mini
      media_player.boven_groep:
      - media_player.pepijn_mini
      - media_player.slaapkamer_hub
      - media_player.zolder_mini_marleen
      - media_player.zolder_mini_martijn
      - media_player.floris_mini
      media_player.beneden_groep:
      - media_player.keuken_hub
      - media_player.woonkamer_mini
      media_player.zolder_groep:
      - media_player.zolder_mini_marleen
      - media_player.zolder_mini_martijn
    players_screen:
    - media_player.keuken_hub
    - media_player.slaapkamer_hub
    primary_spotcast: !input 'primary_spotcast'
    fixed_picture:
      NPO Radio 2: /local/pictures/radio/npo_radio_2.png
    target: !input 'target_entities'
    default_volume_level: !input 'default_volume_level'
- alias: Set variables to be used in the script
  variables:
    target_list: "{% if voice_tts_target is defined %}\n  {{ [ voice_tts_target ]\
      \ }}\n{% else %}\n  {# determine entities of cast integraton #}\n    {%- set\
      \ devices = states | map(attribute='entity_id') | map('device_id') | unique\
      \ | reject('eq',None) | list %}\n    {%- set ns = namespace(entities = []) %}\n\
      \    {%- for device in devices %}\n      {%- set ids = device_attr(device, 'identifiers')\
      \ | list | first %}\n      {%- if ids and ids | length == 2 and ids[0] == 'cast'\
      \ %}\n        {%- set ns.entities = ns.entities + device_entities(device) %}\n\
      \      {%- endif %}\n    {%- endfor %}\n    {% set cast_entities = ns.entities\
      \ %}\n  {# create target lists #}\n  {% if target is defined %}\n    {# create\
      \ lists based on target input #}\n      {% set area_list = target.area_id.replace('\
      \ ' , '').split(',') if target.area_id is string else target.area_id %}\n  \
      \    {% set device_list = target.device_id.replace(' ' , '').split(',') if target.device_id\
      \ is string else target.device_id %}\n      {% set entity_list = target.entity_id.replace('\
      \ ' , '').split(',') if target.entity_id is string else target.entity_id %}\n\
      \  {% else %}\n    {# determine targets based on actions if target not specified\
      \ #}\n      {% set ns = namespace(entity = [], device = [], area = [] ) %}\n\
      \      {% for item in action %}\n        {% set entity = item.target.get('entity_id',\
      \ []) %}\n        {% set device = item.target.get('device_id', []) %}\n    \
      \    {% set area = item.target.get('area_id', []) %}\n        {% set ns.entity\
      \ = ns.entity + [ entity ] if entity is string else entity %}\n        {% set\
      \ ns.device = ns.device + [ device ] if device is string else device %}\n  \
      \      {% set ns.area = ns.area + [ area ] if area is string else area %}\n\
      \      {% endfor %}\n      {% set area_list = ns.area %}\n      {% set device_list\
      \ = ns.device %}\n      {% set entity_list = ns.entity %}\n  {% endif %}\n \
      \ {# create entity list based on device/area input #}\n    {# determine cast\
      \ entities of areas #}\n      {% set ns = namespace(area_cast = []) %}\n   \
      \   {% for area in area_list %}\n        {% set ns.area_cast = ns.area_cast\
      \ + area_entities(area) | select('in', cast_entities) | list %}\n      {% endfor\
      \ %}\n      {% set area_cast = ns.area_cast %}\n    {# determine cast entities\
      \ of devices #}\n      {% set ns = namespace(device_cast = []) %}\n      {%\
      \ for device in device_list %}\n        {% set ns.device_cast = ns.device_cast\
      \ + device_entities(device) | select('in', cast_entities) | list %}\n      {%\
      \ endfor %}\n      {% set device_cast = ns.device_cast %}\n  {# create list\
      \ with all entities #}\n    {{ (area_cast + device_cast + entity_list) | unique\
      \ | list }}\n{% endif %}\n"
    speaker_group_list: '{{ speaker_groups.keys() | list if speaker_groups is defined
      else [] }}'
    players_to_resume: "{# use data from google_home_say_voice script in case it was\
      \ used #}\n  {% if voice_media_player_data is defined %}\n    {{ voice_media_player_data\
      \ }}\n  {% else %}\n    {# determine which media_players are playing and store\
      \ attributes#}\n      {% \n        set all_players_playing = states.media_player\
      \ \n                                    | selectattr('state', 'eq', 'playing')\
      \ \n                                    | map(attribute='entity_id') \n    \
      \                                | list  \n      %}\n{# determine which Google\
      \ Home speakers groups are playing #}\n      {% \n        set all_speaker_groups_playing\
      \ =  voice_groups | default(\n                                          all_players_playing\
      \ \n                                            | select('in', speaker_group_list)\
      \ \n                                            | list )\n      %}\n    {# determine\
      \ which of the targets (including groups members) are playing  #}\n      {%\
      \ set ns = namespace(targets = []) %}\n        {% for target in target_list\
      \ %}\n          {% set ns.targets = ns.targets +  (\n                      \
      \                                speaker_groups[target] \n                 \
      \                                     if target in speaker_group_list \n   \
      \                                                   else [ target ] \n     \
      \                                               ) \n          %}\n        {%\
      \ endfor %}\n      {% set target_playing = ns.targets | select('in', all_players_playing)\
      \ | list %}\n    {# determine which groups should be resumed becaue a single\
      \ target is part of that group #}\n      {% set ns = namespace(groups = [])\
      \ %}\n        {% for group in all_speaker_groups_playing %}\n          {% for\
      \ entity in speaker_groups[group] if entity in target_playing %}\n         \
      \   {% set ns.groups = ns.groups + [group] %}\n          {% endfor %}\n    \
      \    {% endfor %}\n      {% set speaker_groups_resume = ns.groups | unique |\
      \ list %}\n    {# determine if target has subgroups which are playing and add\
      \ to speaker_groups_resume #}\n      {% set ns = namespace(groups = []) %}\n\
      \        {% for target in target_list %}\n          {% set ns.groups = ns.groups\
      \ + \n              (sub_groups[target] | select('in', all_speaker_groups_playing)\
      \ | list)\n              if sub_groups is defined else []     \n        %}\n\
      \        {% endfor %}\n      {% set speaker_groups_resume = speaker_groups_resume\
      \ + ns.groups | unique | list %}\n    {# determine which single entities are\
      \ in a group which is going to be resumed #}\n      {% set ns = namespace(reject\
      \ = []) %}\n      {% for group in speaker_groups_resume %}\n        {% set ns.reject\
      \ = ns.reject + speaker_groups[group] %}\n      {% endfor %}\n      {% set reject_list\
      \ = ns.reject %}\n    {# determine which single playing entities are in a group\
      \ which is a target #}\n      {% set target_group = target_list | select('in',\
      \ speaker_group_list) | reject('in', all_speaker_groups_playing) |list %}\n\
      \      {% set ns = namespace(single_resume = []) %}\n      {% for group in target_group\
      \ %}\n        {% set ns.single_resume = ns.single_resume + speaker_groups[group]\
      \ | select('in', all_players_playing) | list %}\n      {% endfor %}\n      {%\
      \ set single_resume_list = ns.single_resume %}\n    {# combine all the above\
      \ to a list of players which should be resumed #}\n      {% set players_resume\
      \ = (target_playing + speaker_groups_resume + single_resume_list) | reject('in',\
      \ reject_list) | unique | list %}\n      {% set ns = namespace(info=[]) %}\n\
      \      {% for entity in expand(players_resume) %}\n        {% set ns.info =\
      \ ns.info +  [ \n                                      dict(\n             \
      \                           entity_id = entity.entity_id,\n                \
      \                        friendly_name = entity.attributes.friendly_name, \n\
      \                                        media_content_id = entity.attributes.media_content_id\
      \ | default('no media_content'),\n                                        media_title\
      \ = entity.attributes.media_title | default('no title'),\n                 \
      \                       media_artist = entity.attributes.media_artist | default('No\
      \ artist'),\n                                        media_content_type = entity.attributes.media_content_type\
      \ | default('no type'),\n                                        app_name =\
      \ entity.attributes.app_name | default('no app'),\n                        \
      \                entity_picture = entity.attributes.entity_picture | default('no\
      \ pic'),\n                                        volume_level = entity.attributes.volume_level\
      \ | round(2) \n                                        )\n                 \
      \                   ] \n        %}\n      {% endfor %}\n      {{ ns.info }}\n\
      \  {% endif %}\n"
    target_not_playing: "{% set players_resume_entity = players_to_resume | map(attribute='entity_id')\
      \ | list %} {% set ns = namespace(members = []) %} {% for entity in players_resume_entity\
      \ %}\n  {% if entity in speaker_group_list %}\n    {% set ns.members = ns.members\
      \ + speaker_groups[entity] | list %}\n  {% endif %}\n{% endfor %} {% set players_resume_all\
      \ = players_resume_entity + ns.members %} {{ target_list | reject('in', players_resume_all)\
      \ | list }}\n"
    spotify_players_info: "{% \n  set spotify_player_list = states.media_player \n\
      \                              | selectattr('state', 'eq', 'playing')\n    \
      \                          | selectattr('entity_id', 'search', 'media_player.spotify')\
      \ \n                              | map(attribute='entity_id') \n          \
      \                    | list\n%} {% set entities = expand(spotify_player_list)\
      \ %} {% set ns = namespace(info=[]) %} {% for entity in entities %}\n  {% set\
      \ ns.info = ns.info + [ dict(entity_id=entity.entity_id, source=entity.attributes.source)\
      \ ] %}\n{% endfor %} {{ ns.info }}\n"
- alias: Turn non playing entities on if needed
  choose:
  - conditions: '{{ target_not_playing | count > 0 }}'
    sequence:
    - alias: Turn non playing entities on
      service: media_player.turn_on
      target:
        entity_id: '{{ target_not_playing }}'
    - delay: 0.25
- variables:
    volume_old_not_playing: "{% set entities = expand(target_not_playing) %} {% set\
      \ ns = namespace(info=[]) %} {% set volume = default_volume_level | default(0.25)\
      \ %} {% set volume_restore = volume if volume < 1 else [1, volume / 100] | min\
      \ %} {% for entity in entities %}\n  {% set ns.info = ns.info +  [\n       \
      \                       dict(\n                                entity_id = entity.entity_id,\
      \ \n                                volume_level = entity.attributes.volume_level\
      \ | default(\n                                                             \
      \                             volume_restore\n                             \
      \                                                           ) | round(2)\n \
      \                               ) \n                              ] \n  %}\n\
      {% endfor %} {{ ns.info }}\n"
    screen_not_playing: '{{ [] if not players_screen else target_not_playing | select(''in'',
      players_screen) | list }}

      '
- alias: Perform service calls defined in action
  repeat:
    count: 1
    sequence: !input 'actions_to_perform'
- alias: Short delay if required
  choose:
  - conditions:
    - alias: Delay required
      condition: template
      value_template: "{{\n  players_to_resume | count > 0\n  or target_not_playing\
        \ | count > 0\n  or screen_not_playing | count > 0\n}}\n"
    sequence:
    - delay: 4
- alias: Anything to resume?
  choose:
  - conditions:
    - alias: Anything playing
      condition: template
      value_template: '{{ players_to_resume | count > 0 }}'
    sequence:
    - alias: Resume players
      repeat:
        count: '{{ players_to_resume | count }}'
        sequence:
        - alias: Variables for specific media_player
          variables:
            player: '{{ players_to_resume[repeat.index - 1] }}'
            spotify: '{{ player.app_name == ''Spotify'' }}

              '
            stream: "{{ \n  (player.media_content_id).startswith('http')\n}}\n"
            spotcast_account: "{% if voice_spotcast %}\n  {{ voice_spotcast }}\n{%\
              \ else %}\n  {% if player.app_name != 'Spotify' %}\n    {% set spotcast\
              \ = 'Not Spotify' %}\n  {% else %}\n    {% set entity = player.entity_id\
              \ %}\n    {% if speaker_groups and speaker_groups[entity] %}\n     \
              \ {% set members = speaker_groups[entity] %}\n    {% else %}\n     \
              \ {% set members = [] %}\n    {% endif %}\n    {% set list_check = [\
              \ player.entity_id ] + members %}\n    {% set names_check = expand(list_check)\
              \ | map(attribute='name') | list %}\n      {% set spotcast =  spotify_players_info\n\
              \                          | selectattr('source', 'in', names_check)\
              \ \n                          | map(attribute='entity_id') \n      \
              \                    | join \n                          | replace('media_player.spotify_',\
              \ '')\n          \n      %}\n  {% endif %}\n    {{ spotcast if spotcast\
              \ else primary_spotcast }}\n{% endif %}\n"
        - alias: Wait until player is idle again
          wait_template: '{{ states(player.entity_id) in [''idle'', ''off''] }}'
        - alias: Set volume to old volume if needed
          choose:
          - conditions:
            - alias: Volume restore needed
              condition: template
              value_template: "{{\n  player.volume_level | round(2, default=0) \n\
                \  != state_attr(player.entity_id, 'volume_level') | round(2, default=0)\n\
                }}\n"
            sequence:
            - alias: Set volume back to old state
              service: media_player.volume_set
              target:
                entity_id: '{{ player.entity_id }}'
              data:
                volume_level: '{{ player.volume_level | float(default=default_volume_level
                  | default(0.25)) | round(2) }}'
        - alias: Resume playing
          choose:
          - alias: Spotify?
            conditions: '{{ spotify }}'
            sequence:
            - alias: Primary spotcast account?
              choose:
              - conditions: '{{ spotcast_account == primary_spotcast }}'
                sequence:
                - alias: Resume spotify with primary spotcast account
                  service: spotcast.start
                  data:
                    entity_id: '{{ player.entity_id }}'
                    force_playback: true
              default:
              - alias: Resume spotify with specific account
                service: spotcast.start
                data:
                  entity_id: '{{ player.entity_id }}'
                  account: '{{ spotcast_account }}'
                  force_playback: true
          - alias: Stream?
            conditions: '{{ stream }}'
            sequence:
            - alias: Resume stream
              service: media_player.play_media
              target:
                entity_id: '{{ player.entity_id }}'
              data:
                media_content_id: '{{ player.media_content_id }}

                  '
                media_content_type: music
                extra:
                  title: "{% if player.app_name.startswith('TuneIn') %}\n  {{ player.media_artist\
                    \ }}\n{% else %}\n  {{ player.media_title }}\n{% endif %}\n"
                  thumb: "{{\n  fixed_picture[player.media_artist]\n    | default(player.entity_picture)\n\
                    }}\n"
- alias: Restore volume of non playing entities
  choose:
  - conditions:
    - alias: Restore required?
      condition: template
      value_template: "{{ \n  target_not_playing | count > 0 \n}}\n"
    sequence:
    - alias: Adjust volume
      repeat:
        count: '{{ volume_old_not_playing | count }}'
        sequence:
        - alias: Variables for specific media_player
          variables:
            player: '{{ volume_old_not_playing[repeat.index -1] }}'
        - alias: Wait until entity is idle or off
          wait_template: '{{ states(player.entity_id) in [''idle'', ''off''] }}'
        - alias: Set volume to old volume if needed
          choose:
          - conditions:
            - alias: Volume restore needed
              condition: template
              value_template: "{{\n  player.volume_level | round(2, default=0) \n\
                \  != state_attr(player.entity_id, 'volume_level') | round(2, default=0)\n\
                }}\n"
            sequence:
            - alias: Set volume back to old state
              service: media_player.volume_set
              target:
                entity_id: '{{ player.entity_id }}'
              data:
                volume_level: '{{ player.volume_level | float(default=default_volume_level
                  | default(0.25)) | round(2) }}

                  '
- alias: Google Home with screen back to idle screen
  choose:
  - conditions: '{{ screen_not_playing | count > 0 }}'
    sequence:
    - alias: Restore default screen
      repeat:
        count: '{{ screen_not_playing | count }}'
        sequence:
        - variables:
            player: '{{ screen_not_playing[repeat.index -1] }}'
        - alias: Wait until player is idle or off
          wait_template: '{{ states(player) in [''idle'', ''off''] }}'
        - alias: Turn Google Home on to return to idle mode (photo display)
          service: media_player.turn_on
          target:
            entity_id: '{{ player }}'
